import { AutoAcceptAgent } from '../../src/agents/auto-accept-agent';
import { ConfirmationRequest } from '../../src/types';
import { ConfigManager } from '../../src/config/config-manager';

describe('AutoAcceptAgent', () => {
  let agent: AutoAcceptAgent;
  let configManager: ConfigManager;

  beforeEach(() => {
    configManager = ConfigManager.getInstance();
    agent = new AutoAcceptAgent();
  });

  describe('processConfirmationRequest', () => {
    it('should reject requests when auto-accept is disabled', async () => {
      agent.disableAutoAccept();

      const request: ConfirmationRequest = {
        id: 'test-1',
        message: 'Do you want to proceed?',
        operation: 'git_commit',
        timestamp: new Date(),
        riskLevel: 'low'
      };

      const response = await agent.processConfirmationRequest(request);

      expect(response.accepted).toBe(false);
      expect(response.reason).toContain('Auto-accept disabled');
    });

    it('should accept safe git operations when enabled', async () => {
      agent.enableAutoAccept();

      const request: ConfirmationRequest = {
        id: 'test-2',
        message: 'Do you want to commit your changes?',
        operation: 'git_commit',
        timestamp: new Date(),
        riskLevel: 'low'
      };

      const response = await agent.processConfirmationRequest(request);

      expect(response.accepted).toBe(true);
      expect(response.autoGenerated).toBe(true);
    });

    it('should reject dangerous operations', async () => {
      agent.enableAutoAccept();

      const request: ConfirmationRequest = {
        id: 'test-3',
        message: 'rm -rf / - Are you sure?',
        operation: 'file_delete',
        timestamp: new Date(),
        riskLevel: 'high'
      };

      const response = await agent.processConfirmationRequest(request);

      expect(response.accepted).toBe(false);
      expect(response.reason).toContain('danger_pattern');
    });

    it('should respect session limits', async () => {
      // Set low limit for testing
      configManager.updateConfig({ maxAutoAccepts: 1 });
      agent.enableAutoAccept();

      const request1: ConfirmationRequest = {
        id: 'test-4a',
        message: 'Do you want to proceed?',
        operation: 'git_commit',
        timestamp: new Date(),
        riskLevel: 'low'
      };

      const request2: ConfirmationRequest = {
        id: 'test-4b',
        message: 'Do you want to proceed again?',
        operation: 'git_commit',
        timestamp: new Date(),
        riskLevel: 'low'
      };

      // First request should be accepted
      const response1 = await agent.processConfirmationRequest(request1);
      expect(response1.accepted).toBe(true);

      // Second request should be rejected due to limits
      const response2 = await agent.processConfirmationRequest(request2);
      expect(response2.accepted).toBe(false);
      expect(response2.reason).toContain('limits exceeded');
    });
  });

  describe('getSessionStatus', () => {
    it('should return correct session information', () => {
      agent.enableAutoAccept();
      const status = agent.getSessionStatus();

      expect(status.active).toBe(true);
      expect(status.acceptCount).toBe(0);
      expect(status.sessionId).toBeDefined();
      expect(typeof status.timeRemaining).toBe('number');
    });
  });

  describe('testOperation', () => {
    it('should predict acceptance correctly', async () => {
      agent.enableAutoAccept();

      const result = await agent.testOperation('git_commit', 'Do you want to commit?');
      
      expect(result.wouldAccept).toBe(true);
      expect(result.riskLevel).toBeDefined();
      expect(result.reason).toBeDefined();
    });

    it('should predict rejection for dangerous operations', async () => {
      agent.enableAutoAccept();

      const result = await agent.testOperation('file_delete', 'rm -rf /');
      
      expect(result.wouldAccept).toBe(false);
      expect(result.riskLevel).toBe('high');
    });
  });

  describe('configuration updates', () => {
    it('should apply configuration changes', () => {
      const newConfig = {
        maxAutoAccepts: 50,
        sessionTimeout: 30
      };

      agent.updateConfig(newConfig);
      const context = agent.getContext();

      expect(context.config.maxAutoAccepts).toBe(50);
      expect(context.config.sessionTimeout).toBe(30);
    });
  });

  describe('session management', () => {
    it('should reset session correctly', () => {
      agent.enableAutoAccept();
      const originalSessionId = agent.getSessionStatus().sessionId;

      agent.resetSession();
      const newSessionId = agent.getSessionStatus().sessionId;

      expect(newSessionId).not.toBe(originalSessionId);
      expect(agent.getSessionStatus().acceptCount).toBe(0);
    });
  });
});