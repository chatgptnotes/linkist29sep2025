import { 
  AutoAcceptConfig, 
  ConfirmationRequest, 
  ConfirmationResponse, 
  AutoAcceptSession,
  AuditLogEntry,
  AgentContext
} from '../types';
import { ConfigManager } from '../config/config-manager';
import { Logger } from '../utils/logger';
import { SecurityChecker } from '../utils/security-checker';
import { v4 as uuidv4 } from 'uuid';

export class AutoAcceptAgent {
  private config: AutoAcceptConfig;
  private logger: Logger;
  private securityChecker: SecurityChecker;
  private session: AutoAcceptSession;

  constructor() {
    this.config = ConfigManager.getInstance().getConfig();
    this.logger = Logger.getInstance();
    this.securityChecker = new SecurityChecker(this.config);
    this.session = this.createSession();
    
    this.logger.info('Auto-Accept Agent initialized', {
      enabled: this.config.enabled,
      sessionId: this.session.id
    });
  }

  private createSession(): AutoAcceptSession {
    return {
      id: uuidv4(),
      startTime: new Date(),
      acceptCount: 0,
      enabled: this.config.enabled,
      lastActivity: new Date()
    };
  }

  public async processConfirmationRequest(request: ConfirmationRequest): Promise<ConfirmationResponse> {
    this.session.lastActivity = new Date();
    
    this.logger.info('Processing confirmation request', {
      requestId: request.id,
      operation: request.operation,
      message: request.message.substring(0, 100) + '...'
    });

    // Check if auto-accept is enabled
    if (!this.config.enabled || !this.session.enabled) {
      return this.createResponse(request, false, 'Auto-accept disabled');
    }

    // Check session limits
    if (this.isSessionExpired() || this.hasExceededLimits()) {
      return this.createResponse(request, false, 'Session limits exceeded');
    }

    // Perform security assessment
    const assessment = this.securityChecker.assessRisk(request);
    
    let decision: boolean;
    let reason: string;

    switch (assessment.decision) {
      case 'allow':
        decision = true;
        reason = `Auto-accepted: ${assessment.reason}`;
        this.session.acceptCount++;
        break;
      
      case 'deny':
        decision = false;
        reason = `Auto-rejected: ${assessment.reason}`;
        break;
      
      case 'ask':
      default:
        decision = false;
        reason = `Requires manual approval: ${assessment.reason}`;
        break;
    }

    const response = this.createResponse(request, decision, reason);
    
    // Log the decision
    await this.auditDecision(request, response, assessment);
    
    return response;
  }

  private createResponse(
    request: ConfirmationRequest, 
    accepted: boolean, 
    reason: string
  ): ConfirmationResponse {
    return {
      id: uuidv4(),
      accepted,
      reason,
      timestamp: new Date(),
      autoGenerated: true
    };
  }

  private async auditDecision(
    request: ConfirmationRequest,
    response: ConfirmationResponse,
    assessment: any
  ): Promise<void> {
    const auditEntry: AuditLogEntry = {
      timestamp: new Date(),
      sessionId: this.session.id,
      requestId: request.id,
      operation: request.operation,
      message: request.message,
      decision: response.accepted ? 'accept' : 'reject',
      reason: response.reason,
      riskLevel: assessment.riskLevel,
      userOverride: false
    };

    this.logger.audit(auditEntry);
  }

  private isSessionExpired(): boolean {
    const now = new Date();
    const sessionAge = now.getTime() - this.session.startTime.getTime();
    const timeoutMs = this.config.sessionTimeout * 60 * 1000;
    
    return sessionAge > timeoutMs;
  }

  private hasExceededLimits(): boolean {
    return this.session.acceptCount >= this.config.maxAutoAccepts;
  }

  public getSessionStatus(): {
    active: boolean;
    acceptCount: number;
    remainingAccepts: number;
    timeRemaining: number;
    sessionId: string;
  } {
    const now = new Date();
    const sessionAge = now.getTime() - this.session.startTime.getTime();
    const timeoutMs = this.config.sessionTimeout * 60 * 1000;
    const timeRemaining = Math.max(0, timeoutMs - sessionAge);

    return {
      active: this.config.enabled && this.session.enabled && !this.isSessionExpired(),
      acceptCount: this.session.acceptCount,
      remainingAccepts: Math.max(0, this.config.maxAutoAccepts - this.session.acceptCount),
      timeRemaining: Math.floor(timeRemaining / 1000), // seconds
      sessionId: this.session.id
    };
  }

  public enableAutoAccept(): void {
    this.config.enabled = true;
    this.session.enabled = true;
    this.session = this.createSession(); // Reset session
    ConfigManager.getInstance().setEnabled(true);
    
    this.logger.info('Auto-accept enabled', { sessionId: this.session.id });
  }

  public disableAutoAccept(): void {
    this.config.enabled = false;
    this.session.enabled = false;
    ConfigManager.getInstance().setEnabled(false);
    
    this.logger.info('Auto-accept disabled', { sessionId: this.session.id });
  }

  public resetSession(): void {
    this.session = this.createSession();
    this.logger.info('Session reset', { sessionId: this.session.id });
  }

  public updateConfig(newConfig: Partial<AutoAcceptConfig>): void {
    this.config = { ...this.config, ...newConfig };
    this.securityChecker.updateConfig(this.config);
    ConfigManager.getInstance().updateConfig(newConfig);
    
    this.logger.info('Configuration updated');
  }

  public getContext(): AgentContext {
    return {
      config: this.config,
      session: this.session,
      logger: this.logger
    };
  }

  public async testOperation(operation: string, message: string): Promise<{
    wouldAccept: boolean;
    reason: string;
    riskLevel: 'low' | 'medium' | 'high';
  }> {
    const testRequest: ConfirmationRequest = {
      id: 'test-' + uuidv4(),
      message,
      operation,
      timestamp: new Date(),
      riskLevel: 'medium'
    };

    const assessment = this.securityChecker.assessRisk(testRequest);
    
    return {
      wouldAccept: assessment.decision === 'allow' && this.config.enabled,
      reason: assessment.reason,
      riskLevel: assessment.riskLevel
    };
  }
}